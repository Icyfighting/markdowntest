---
layout: post
title: "Java memory management learning (1)"
subtitle: "Stack & Heap & Method Area"
author: "Bing Yan"
header-img: "img/post-bg-java.jpg"
header-mask: 0.2
tags:
  - Java
  - Learning
---

为什么学习java内存管理？

首先我们要了解我们为什么要学习java虚拟机的内存管理，不是java的gc垃圾回收机制都帮我们释放了内存了吗？但是在写程序的过程中却也往往因为不懂内存管理而造成了一些不容易察觉到的内存问题，
并且在内存问题出现的时候，也不能很快的定位并解决。因此，了解并掌握Java的内存管理是我们必须要做的是事，也只有这样才能写出更好的程序，更好地优化程序的性能。

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：

![](/img/java-mem-1.jpg)

最重要的是了解栈内存（Stack）和堆内存（Heap）和方法区（Method Area）这三部分：

**Java栈(Stack):**
>在栈内存中保存的是堆内存空间的访问地址。Java栈是Java方法执行的内存模型每个方法在执行的同时都会创建一个栈帧的用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每个方法从调用直至执行完成的过程就对应着一个栈帧在虚拟机中入栈和出栈的过程。

**Java堆(Heap):**
>堆内存用来存放由new创建的对象实例和数组。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例 。Java堆是垃圾收集器管理的主要区域。Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。
在实现上，既可以实现固定大小的，也可以是扩展的。如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。

**方法区(Method Area):**
>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。
>
>运行时常量池：是方法区的一部分，它用于存放编译期生成的各种字面量和符号引用。

**Stack和Heap的联系和区别:**
区别:
>1.各司其职:
>最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内中。
>
>2.独有还是共享:
>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
>3.异常错误:
>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。
>4.空间大小:
>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。
