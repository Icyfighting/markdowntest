---
layout: post
title: "Design Patterns (5)"
subtitle: "Design patterns -- Proxy "
author: "Bing Yan"
header-img: "img/dp-proxy/post-bg-java.jpg"
header-mask: 0.2
catalog: true
tags:
  - Java
  - Design Patterns
  - Learning
---
## 前言

经过上几次的设计模式基础的学习，已经了解了设计模式的意义和基本原则。<br/>
从这次学习开始，主要针对20多种具体的设计模式的意义，场景，和具体实现来深入学习。<br/>
这些学习的内容，都是根据网络上对于设计模式的书籍、博客等内容进行整理。<br/>
本次学习代理(Proxy)模式。

## 正文
### 什么是代理(Proxy)模式

&ensp;&ensp;&ensp;&ensp;在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。<br/>

&ensp;&ensp;&ensp;&ensp;在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。<br/>
&ensp;&ensp;&ensp;&ensp;由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<br/>

### 代理模式特点
<br/>
优点： <br/>

*   代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
*   代理对象可以扩展目标对象的功能；
*   代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
<br/>
缺点： <br/>

*   在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
*   增加了系统的复杂度；
<br/>

### 代理模式的结构

代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问。
<br/>
工厂方法模式构成要素：<br/>

*   抽象主题（Subject）类: 通过接口或抽象类声明真实主题和代理对象实现的业务方法。
*   真实主题（Real Subject）类: 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
*   代理（Proxy）类: 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。

<br/>
结构图如下图所示: <br/>

![](/img/dp-proxy/proxy-1.png)

<br/>

### 代理模式的分类：

*   静态代理：<br/>
静态代理就是写死了在代理对象中执行这个方法前后执行添加功能的形式，每次要在接口中添加一个新方法，则需要在目标对象中实现这个方法，并且在代理对象中实现相应的代理方法。<br/>
*   动态代理（jdk动态代理、cglib动态代理、Spring和AspectJ实现的动态代理）: <br/>
Jdk的动态代理，是使用反射技术获得类的加载器并且创建实例，根据类执行的方法在执行方法的前后发送通知。
<br/>

### 代理模式的实现
<br/>

```
package proxy;
public class ProxyTest
{
    public static void main(String[] args)
    {
        Proxy proxy=new Proxy();
        proxy.Request();
    }
}
//抽象主题
interface Subject
{
    void Request();
}
//真实主题
class RealSubject implements Subject
{
    public void Request()
    {
        System.out.println("访问真实主题方法...");
    }
}
//代理
class Proxy implements Subject
{
    private RealSubject realSubject;
    public void Request()
    {
        if (realSubject==null)
        {
            realSubject=new RealSubject();
        }
        preRequest();
        realSubject.Request();
        postRequest();
    }
    public void preRequest()
    {
        System.out.println("访问真实主题之前的预处理。");
    }
    public void postRequest()
    {
        System.out.println("访问真实主题之后的后续处理。");
    }
}
```

程序的运行结果如下：<br/>
>访问真实主题之前的预处理。<br/>
访问真实主题方法...<br/>
访问真实主题之后的后续处理。<br/>

### 模式的应用场景

代理(Proxy)模式通常适用于以下场景:<br/>

*   远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
*   虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
*   安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
*   智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
*   延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。

### 模式的扩展

前面介绍的代理模式存在以下缺点：<br/>
*   真实主题与代理主题一一对应，增加真实主题也要增加代理。
*   设计代理以前真实主题必须事先存在，不太灵活。

<br/>
而采用态代理模式可以解决以上问题，如 SpringAOP，其结构如下图所示：<br/>

![](/img/dp-proxy/proxy-2.png)
<br/>



## 总结
&ensp;&ensp;&ensp;&ensp;所谓的代理，就是一个人或者一个机构代表另外一个人或者另外一个机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象中间起到中介的作用。<br/>
&ensp;&ensp;&ensp;&ensp;静态代理比动态代理更符合OOP原则，在日常开发中使用也较多。<br/>
&ensp;&ensp;&ensp;&ensp;动态代理在开发框架时使用较多，例如大名鼎鼎的Spring。<br/>
&ensp;&ensp;&ensp;&ensp;而上学时候，老师举了一个简单通俗的例子来说明代理模式：婚礼举办公司。对于结婚的人，只需要负责美美哒结婚就可以了。至于婚礼前的场地布置，婚礼后的场地清理，都不需要被代理人操心，都是由婚庆公司代理来操心。所以说技术和艺术都是源自于生活~

## 参考资料
此次学习主要依赖于下面技术网站:<br/> 
http://c.biancheng.net/view/1359.html <br/>
https://www.jianshu.com/p/305c8da4563d <br/>

